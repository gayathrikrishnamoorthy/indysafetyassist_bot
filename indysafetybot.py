# -*- coding: utf-8 -*-
"""indysafetybot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YlH0bWZhmAlQ-GMPGrTmgr8dsVxTtgFD
"""

!pip install python-telegram-bot==13.15 pyngrok pymongo dnspython certifi numpy -q sentence-transformers

"""# Start and Expose Server via ngrok"""

!ngrok config add-authtoken 2xOUK5JVJs3TDPJ7V0Xs4JmcXzo_3gu1UtDXuKMzL6QHdkSoN

from pyngrok import ngrok

# Replace this with your ngrok auth token (get from https://dashboard.ngrok.com)
NGROK_AUTH_TOKEN = "2xOUK5JVJs3TDPJ7V0Xs4JmcXzo_3gu1UtDXuKMzL6QHdkSoN"

# Set auth token and create tunnel
ngrok.set_auth_token(NGROK_AUTH_TOKEN)
public_url = ngrok.connect(8443, bind_tls=True).public_url
print("Your public webhook URL is:", public_url)

public_url = ngrok.connect(8443, bind_tls=True)
print("Your public webhook URL is:", public_url)

from google.colab import files
uploaded = files.upload()

from telegram import Bot
TOKEN = "7418699247:AAF2eI8vUwDKcU9iXVl8rajdiRt7bjoEMsI"  # use your actual token
bot = Bot(token=TOKEN)

# Set the webhook
webhook_url = "https://c3a0-34-74-152-79.ngrok-free.app/webhook"
bot.set_webhook(url=webhook_url)

print("Webhook has been set to:", webhook_url)

import logging
from flask import Flask, request, jsonify
from math import radians, cos, sin, asin, sqrt
from pymongo import MongoClient
from bson.objectid import ObjectId
from telegram import (Bot, Update, KeyboardButton, ReplyKeyboardMarkup,
                      ReplyKeyboardRemove, InlineKeyboardButton,
                      InlineKeyboardMarkup)
from telegram.ext import (Dispatcher, CommandHandler, MessageHandler, Filters,
                          CallbackQueryHandler, ConversationHandler)
from threading import Thread
from pyngrok import ngrok
import time
import sys
from sentence_transformers import SentenceTransformer, util
from datetime import datetime, timedelta
from bson.objectid import ObjectId
# Add this import for ML
import pickle

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOKEN      = "7418699247:AAF2eI8vUwDKcU9iXVl8rajdiRt7bjoEMsI"  # <--- REPLACE WITH YOUR BOT TOKEN
MONGO_URI  = "mongodb+srv://gayathrikit2023:NO4S1TqBzUpKLjkO@cluster0.o7tbjbp.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"   # <--- REPLACE WITH YOUR MONGODB ATLAS URI
ADMIN_IDS  = [6912204632] # <--- REPLACE WITH YOUR ACTUAL TELEGRAM USER ID(s)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ASK_INFO = range(1)
KNOWLEDGE_BASE = {
    "non-emergency police number":
        "The non-emergency number for *Indianapolis Metro Police* is **+1 317-327-3811**.",
    "nearest hospital":
        "A major hospital near downtown is *IU Health Methodist*, 1701 N Senate Blvd. Phone: +1 317-962-2000.",
    "first aid for burns":
        "Cool the burn with running water for 10-20 min. Do **not** apply ice or butter. Cover loosely. For serious burns, **dial 911**.",
    "shelter locations":
        "Call **2-1-1** or visit https://in211.communityos.org/ for active emergency shelters in Marion County.",
    "power outage reporting":
        "Report outages to **AES Indiana** 24/7 at 317-261-8111 (option 1) or see the live map: https://www.aesindiana.com/outages",
    "snake bite first aid":
        "Keep the person calm, remove tight items, immobilise the limb, **do not** cut or suck the wound. Call **911** immediately."
}
nlp_model        = SentenceTransformer("all-MiniLM-L6-v2")
FAQ_QUESTIONS    = list(KNOWLEDGE_BASE.keys())
FAQ_EMBEDDINGS   = nlp_model.encode(FAQ_QUESTIONS)   # shape (N, 384)
# Flask app & logger
app = Flask(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Telegram bot & dispatcher
bot         = Bot(token=TOKEN)
dispatcher  = Dispatcher(bot, None, use_context=True)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MongoDB Connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
client = None
reports_col = None
try:
    logger.info(f"Attempting to connect to MongoDB with URI: {MONGO_URI[:30]}...")
    import certifi
    ca = certifi.where()
    client = MongoClient(MONGO_URI, tlsCAFile=ca)
    client.admin.command('ping')
    reports_col = client["hazard_reports"]["reports"]
    # during start-up (right after reports_col):
    users_col = client["hazard_reports"]["users"]
    # Location index for fast $near queries
    users_col.create_index([("location", "2dsphere")])
    alerts_col = client["hazard_reports"]["alerts"]

    logger.info("MongoDB Atlas connected successfully!")
except Exception as e:
    logger.error(f"Failed to connect to MongoDB Atlas: {e}")
    reports_col = None # Ensure it's None if connection failed

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ML Model Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# This list is for reference/display. Your model should directly output these strings.
# Based on your dataset image, "Fire Hazard" is a common label.
# Adjust these categories if your model predicts different specific strings.
HAZARD_CATEGORIES = [
    "Fire Hazard", "Gas Leak", "Violent crime", "Accident", "Flood",
    "Road Hazrad", "Power Outage", "Traffic Signal Issue", "Public Disturbance",
    "Infrastructure Damage", "Other"
]
VECTORIZER = None
HAZARD_CLASSIFIER = None

try:
    with open('vectorizer.pkl', 'rb') as f:
        VECTORIZER = pickle.load(f)
    with open('model.pkl', 'rb') as f:
        HAZARD_CLASSIFIER = pickle.load(f)
    logger.info("Loaded vectorizer.pkl and model.pkl successfully!")
except FileNotFoundError:
    logger.warning("vectorizer.pkl / model.pkl not found â€“ ML classification disabled.")
except Exception as e:
    logger.error(f"Error loading ML components: {e}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Memory helpers
user_sessions  = {}

# Conversation states
ASK_DESCRIPTION, ASK_LOCATION, ASK_DETAIL, ASK_DANGER, ASK_PHOTO = range(5)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BASIC COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def start(update, ctx):
    # Using MarkdownV2 requires careful escaping of all special characters.
    # Special characters: _, *, [, ], (, ), ~, `, >, #, +, -, =, |, {, }, ., !
    menu = (
        "ğŸ‘‹ *Hello\! I am IndySafetyAssistBot*\\.\n\n"
        " /set\_location \\- share your location for alerts\n"
        " /report\_hazard \\- report a public hazard\n"
        " /my\\_reports \\- view your submitted reports\n"
        " /Emergency\_alerts \\- current emergency alerts\n"
        " /info \\- public\\-safety resources\n"
        " /help \\- how to use this bot"
    )
    update.message.reply_text(menu, parse_mode="MarkdownV2")
    logger.info(f"Received /start from {update.effective_user.id}")

def help_cmd(update, ctx):
    update.message.reply_text("Use /report_hazard, /set_location, /my_reports, /Emergency_alerts, /info.")
    logger.info(f"Received /help from {update.effective_user.id}")
def haversine_km(lat1, lon1, lat2, lon2):
    dlon, dlat = radians(lon2-lon1), radians(lat2-lat1)
    a = sin(dlat/2)**2 + cos(radians(lat1))*cos(radians(lat2))*sin(dlon/2)**2
    return 6371 * 2*asin(sqrt(a))  # Earth km

def dispatch_alert_to_users(alert_id):
    alert = alerts_col.find_one({"_id": ObjectId(alert_id)})
    if not alert:
        logger.error("Alert not found:", alert_id); return

    clat, clon = alert["center"][1], alert["center"][0]
    radius_km   = alert["radius_m"]/1000
    msg_body = (
        f"âš ï¸â›ˆï¸ *EMERGENCY ALERT: {alert['alert_type'].upper()}!* â›ˆï¸âš ï¸\n"
        f"{alert['message']}\n\n"
        f"[More details]({alert['url']})\n\n"
        "Stay safe!"
    )
    buttons = InlineKeyboardMarkup([[
        InlineKeyboardButton("View Safety Tips", callback_data="tips"),
        InlineKeyboardButton("I'm Safe", callback_data=f"safe_{alert_id}")
    ]])

    # Find users in radius
    for user in users_col.find():
        loc = user.get("location", {})
        if not loc: continue
        ulat, ulon = loc["coordinates"][1], loc["coordinates"][0]
        if haversine_km(clat, clon, ulat, ulon) <= radius_km:
            uid = user["_id"]
            try:
                bot.send_message(uid, msg_body,
                                 parse_mode="Markdown",
                                 reply_markup=buttons,
                                 disable_web_page_preview=True)
                alerts_col.update_one({"_id": alert["_id"]},
                                      {"$addToSet": {"recipients": uid}})
            except Exception as e:
                logger.error(f"Send alert to {uid} failed: {e}")
def alert_callback(update, ctx):
    query = update.callback_query
    data  = query.data

    if data == "tips":
        query.answer()
        query.message.reply_text(
            "ğŸ›¡ï¸ *Basic Safety Tips:*\n"
            "â€¢ Stay indoors\nâ€¢ Keep emergency kit ready\n"
            "â€¢ Follow official instructions",
            parse_mode="Markdown"
        )

    elif data.startswith("safe_"):
        alert_id = data.split("_", 1)[1]
        alerts_col.update_one({"_id": ObjectId(alert_id)},
                              {"$addToSet": {"acknowledged": query.from_user.id}})
        query.answer("Thanks for confirming your safety! âœ…", show_alert=False)

dispatcher.add_handler(CallbackQueryHandler(alert_callback,
                                            pattern="^(tips|safe_)"))
def _format_alert(a, uid):
    """Return a single alert string with âœ… / â— mark."""
    mark = "âœ…" if uid in a.get("acknowledged", []) else "â—"
    short = (a["message"][:120] + "â€¦") if len(a["message"]) > 120 else a["message"]
    return (f"{mark} *{a['alert_type']}* â€“ {a['severity']}\n"
            f"{short}\n[Details]({a['url']})")
def alerts(update, context):
    uid = update.effective_user.id
    chat_id = update.effective_chat.id
    bot = context.bot

    since_ts = (datetime.utcnow() - timedelta(days=6)).timestamp()
    recent_alerts = alerts_col.find({"ts": {"$gte": since_ts}}).sort("ts", -1)

    seen = set()
    shown = 0
    for a in recent_alerts:
        key = str(a["_id"])
        if key in seen:
            continue
        seen.add(key)

        bot.send_message(
            chat_id=chat_id,
            text=_format_alert(a, uid),
            parse_mode="Markdown",
            disable_web_page_preview=True
        )
        shown += 1

    if shown == 0:
        bot.send_message(chat_id, "âœ… No recent alerts in the past 6 days.")
def best_faq_match(user_text: str, threshold: float = 0.55):
    """Return (question, answer, score) or (None, None, 0)."""
    emb = nlp_model.encode(user_text)
    scores = util.cos_sim(emb, FAQ_EMBEDDINGS)[0]        # tensor of similarities
    best_idx = int(scores.argmax())
    best_score = float(scores[best_idx])

    if best_score >= threshold:
        q = FAQ_QUESTIONS[best_idx]
        return q, KNOWLEDGE_BASE[q], best_score
    return None, None, best_score

def info_start(update, ctx):
    update.message.reply_text(
        "â„¹ï¸  What safety info do you need?\n"
        "E.g. police non-emergency number*, *nearest hospital*, *first aid for burns â€¦ \n\nYou can type /cancel anytime to exit.",
        parse_mode="Markdown"
    )
    return ASK_INFO

def info_answer(update, ctx):
    query  = update.message.text.strip()
    q, ans, score = best_faq_match(query)
    if ans:
            update.message.reply_text(ans, parse_mode="Markdown")
    else:
        update.message.reply_text(
            "âŒ Sorry, I donâ€™t have that info yet. Please rephrase or dial *211* for Indiana community services."
        )

    return ASK_INFO  # Stay in the info loop

def info_cancel(update, ctx):
    update.message.reply_text("â„¹ï¸ Info request cancelled.")
    return ConversationHandler.END

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOCATION MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def set_location(update, ctx):
    uid = update.effective_user.id
    kb = [[KeyboardButton("ğŸ“ Share My Location", request_location=True)]]
    update.message.reply_text("Tap the button below to share your location for alerts.",
                              reply_markup=ReplyKeyboardMarkup(kb, one_time_keyboard=True))
    logger.info(f"Received /set_location from {uid}")

def handle_location(update, ctx):
    uid = update.effective_user.id
    loc = update.message.location
    users_col.update_one(
        {"_id": uid},
        {"$set": {
            "location": {"type": "Point",
                         "coordinates": [loc.longitude, loc.latitude]},
            "updated":  time.time()}
        },
        upsert=True
    )
    update.message.reply_text(
        f"âœ… Location saved!\nLat: {loc.latitude:.5f}, Lon: {loc.longitude:.5f}",
        reply_markup=ReplyKeyboardRemove()
    )

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REPORT HAZARD CONVERSATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def report_hazard(update, ctx):
    uid = update.effective_user.id
    user_sessions[uid] = {} # Initialize session for new report
    update.message.reply_text("ğŸ“ Describe the hazard (e.g., pothole, fallen tree).\n\nYou can type /cancel anytime to exit.",
                              reply_markup=ReplyKeyboardRemove())
    logger.info(f"Received /report_hazard from {uid}")
    return ASK_DESCRIPTION

def get_description(update, ctx):
    uid = update.effective_user.id
    description = update.message.text
    user_sessions[uid]["description"] = description
    logger.info(f"Description for {uid}: {description}")

    predicted_category = "Uncategorized"
    if VECTORIZER and HAZARD_CLASSIFIER:
        try:
            X = VECTORIZER.transform([description])      # <-- turn text into TF-IDF vector
            predicted_category = HAZARD_CLASSIFIER.predict(X)[0]
            user_sessions[uid]["predicted_category"] = predicted_category

            bot.send_message(
                chat_id=uid,
                text=f"ğŸ’¡ I think this is a *{predicted_category}*.",
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"ML prediction error for {uid}: {e}")
            bot.send_message(chat_id=uid,
                             text="âš ï¸ Couldn't categorize the hazard automatically.",
                             parse_mode="Markdown")
    else:
        logger.info("ML components unavailable â€“ skipping classification.")


    kb = [[KeyboardButton("ğŸ“ Send Location", request_location=True)]]
    update.message.reply_text("ğŸ“ Send the hazard location.", reply_markup=ReplyKeyboardMarkup(kb, one_time_keyboard=True))
    return ASK_LOCATION


def get_hazard_location(update, ctx):
    uid = update.effective_user.id
    location = update.message.location
    user_sessions[uid]["location"] = {"lat": location.latitude, "lon": location.longitude}
    logger.info(f"Hazard location for {uid}: {location.latitude}, {location.longitude}")
    update.message.reply_text("ğŸ“Œ Provide more details about the location (e.g., 'near the park entrance').")
    return ASK_DETAIL

def get_detail(update, ctx):
    uid = update.effective_user.id
    detail = update.message.text
    user_sessions[uid]["location_detail"] = detail
    logger.info(f"Location detail for {uid}: {detail}")

    buttons = [[InlineKeyboardButton("Yes", callback_data="danger_yes"),
                InlineKeyboardButton("No",  callback_data="danger_no")]]
    update.message.reply_text("âš ï¸ Is this hazard causing immediate danger to public safety?",
                              reply_markup=InlineKeyboardMarkup(buttons))
    return ASK_DANGER
def danger_response(update, ctx):
    query = update.callback_query
    uid = query.from_user.id
    immediate_danger = "Yes" if query.data == 'danger_yes' else "No"
    user_sessions[uid]["immediate_danger"] = immediate_danger
    logger.info(f"Immediate danger for {uid}: {immediate_danger}")
    query.edit_message_text(text=f"âš ï¸ Immediate danger: {immediate_danger}")
    update.effective_message.reply_text("ğŸ“¸ Please send a photo of the hazard, or /skip if you don't have one.")
    return ASK_PHOTO

def get_photo(update, ctx):
    uid = update.effective_user.id
    photo_id = update.message.photo[-1].file_id # Get the highest resolution photo file_id
    user_sessions[uid]["photo_id"] = photo_id
    logger.info(f"Photo received for {uid}: {photo_id}")
    return save_and_confirm(update, ctx)

def skip_photo(update, ctx):
    uid = update.effective_user.id
    logger.info(f"Photo skipped for {uid}")
    return save_and_confirm(update, ctx)

def save_and_confirm(update, ctx):
    uid    = update.effective_user.id
    report = user_sessions.pop(uid, {})
    report["user_id"] = uid
    report["status"]  = "Pending"           # initial status

    if reports_col is not None: # Use 'is not None' for robust check
        try:
            ref_id = reports_col.insert_one(report).inserted_id
            logger.info(f"Report saved to DB for {uid}. Ref ID: {ref_id}")
            update.message.reply_text(
                f"âœ… Hazard report submitted!\nReference ID: `{ref_id}`",
                parse_mode="Markdown", reply_markup=ReplyKeyboardRemove()
            )
        except Exception as e:
            logger.error(f"Error saving report for {uid}: {e}")
            update.message.reply_text(
                "âŒ Sorry, there was an error submitting your report. Please try again later.",
                reply_markup=ReplyKeyboardRemove()
            )
    else:
        logger.error(f"MongoDB collection not available. Report not saved for {uid}.")
        update.message.reply_text(
            "âŒ Sorry, the database is not available right now. Your report could not be saved. Please try again later.",
            reply_markup=ReplyKeyboardRemove()
        )
    return ConversationHandler.END

def cancel(update, ctx):
    uid = update.effective_user.id
    user_sessions.pop(uid, None) # Clear any ongoing session data
    update.message.reply_text("âŒ Report submission canceled.", reply_markup=ReplyKeyboardRemove())
    logger.info(f"Conversation canceled for {uid}")
    return ConversationHandler.END

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ VIEW REPORTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def my_reports(update, ctx):
    uid = update.effective_user.id
    logger.info(f"Received /my_reports from {uid}")

    if reports_col is None: # Use 'is None' for robust check
        update.message.reply_text("âŒ Sorry, the database is not available. Cannot retrieve reports.")
        logger.error(f"MongoDB collection not available. Cannot retrieve reports for {uid}.")
        return

    try:
        # Fetch up to 10 latest reports for the user
        docs = list(reports_col.find({"user_id": uid}).sort("_id", -1).limit(10))
        if not docs:
            update.message.reply_text("ğŸ—‚ï¸ You have no reports yet.")
            return

        for i, doc in enumerate(docs, 1):
            msg = (f"   *Report {i}*\n\n"
                   f"ğŸ“ {doc.get('description', 'N/A')}\n"
                   f"ğŸ’¡ Type (ML): *{doc.get('predicted_category', 'N/A')}*\n" # Display predicted category
                   f"ğŸ“ {doc['location']['lat']:.5f}, {doc['location']['lon']:.5f}\n"
                   f"ğŸ“Œ {doc.get('location_detail', 'â€”')}\n"
                   f"âš ï¸ Danger: {doc.get('immediate_danger','?')}\n"
                   f"ğŸ”– Status: *{doc.get('status','?')}*\n"
                   f"ID: `{doc['_id']}`")
            update.message.reply_text(msg, parse_mode="Markdown")
            if doc.get("photo_id"):
                ctx.bot.send_photo(chat_id=uid, photo=doc["photo_id"])
    except Exception as e:
        logger.error(f"Error retrieving reports for {uid}: {e}")
        update.message.reply_text("âŒ Sorry, an error occurred while retrieving your reports.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ADMIN ENDPOINT (Flask) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def view_report_callback(update, ctx):
    query = update.callback_query
    user_id = query.from_user.id

    report_id = query.data.split("_", maxsplit=2)[-1]

    try:
        report = reports_col.find_one({"_id": ObjectId(report_id)})
        if not report:
            query.answer("Report not found.")
            return

        # Format the report details
        text = (
            f"ğŸ“¢ Update for report\n\n"
            f"  Report ID: `{report_id}`\n"
            f"  Location: {report.get('location_detail', 'N/A')}\n"
            f"  Type: {report.get('predicted_category', 'Unknown').title()}\n"
            f"  Description: {report.get('description', 'No description')}\n"
            f"  Status: *{report.get('status', 'Pending')}*"
        )

        # Send updated report details

        query.edit_message_text(
            text=text,
            parse_mode="Markdown",

        )

    except Exception as e:
        logger.error(f"Error handling view_report callback for {report_id}: {e}")
        query.answer("Something went wrong.")


def notify_user(user_id, report_id, new_status):
    hazard_type = "Hazard"
    try:
        doc = reports_col.find_one({"_id": ObjectId(report_id)}, {"predicted_category": 1})
        if doc and doc.get("predicted_category"):
            hazard_type = doc["predicted_category"].title()
    except Exception as e:
        logger.warning("Could not fetch predicted_category for %s : %s", report_id, e)
    message = ( f"ğŸ“¢ Update for report `{report_id}`: *{new_status}*" )
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("ğŸ” View Report", callback_data=f"view_report_{report_id}")
    ]])
    try:
        # Use the bot object from the global scop
        bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode="Markdown",
            reply_markup=keyboard
        )
        logger.info(f"Notification sent to user {user_id} for report {report_id} status {new_status}")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about report {report_id} status {new_status}: {e}")

@app.route("/update_status/<report_id>", methods=["POST"])
def update_status(report_id):
    admin_id_str = request.headers.get("X-Admin-ID")
    if not admin_id_str:
        logger.warning("Unauthorized access attempt: No X-Admin-ID header.")
        return jsonify({"error": "unauthorized: Admin ID required"}), 401 # Unauthorized

    try:
        admin_id = int(admin_id_str)
        if admin_id not in ADMIN_IDS:
            logger.warning(f"Unauthorized access attempt: Admin ID {admin_id} not in ADMIN_IDS.")
            return jsonify({"error": "unauthorized: Admin ID not allowed"}), 403 # Forbidden
    except ValueError:
        logger.warning(f"Unauthorized access attempt: Invalid X-Admin-ID format: {admin_id_str}")
        return jsonify({"error": "unauthorized: Invalid Admin ID format"}), 400 # Bad Request

    data = request.get_json()
    new_status = data.get("status")
    if not new_status:
        return jsonify({"error": "status field is required"}), 400 # Bad Request

    logger.info(f"Admin {admin_id} attempting to update report {report_id} to status: {new_status}")

    if reports_col is None: # Use 'is None' for robust check
        logger.error("MongoDB collection not available. Cannot update status.")
        return jsonify({"error": "database not available"}), 503 # Service Unavailable

    try:
        # Find the report to get the user_id for notification
        report_doc = reports_col.find_one({"_id": ObjectId(report_id)})
        if not report_doc:
            logger.warning(f"Report {report_id} not found for status update.")
            return jsonify({"error": "report not found"}), 404 # Not Found

        result = reports_col.update_one(
            {"_id": ObjectId(report_id)},
            {"$set": {"status": new_status}}
        )

        if result.modified_count == 1:
            logger.info(f"Report {report_id} status updated to {new_status}.")
            user_to_notify = report_doc.get("user_id")
            if user_to_notify:
                notify_user(user_to_notify, report_id, new_status)
            return jsonify({"message": "status updated"}), 200
        else:
            logger.warning(f"Report {report_id} status not modified (perhaps already {new_status}).")
            return jsonify({"message": "status not modified (perhaps already the same)"}), 200 # No change needed, still OK
    except Exception as e:
        logger.error(f"Error updating report {report_id} status: {e}")
        return jsonify({"error": "internal server error"}), 500 # Internal Server Error
@app.route("/trigger_alert", methods=["POST"])
def trigger_alert():
    admin_id_str = request.headers.get("X-Admin-ID")
    if not admin_id_str or int(admin_id_str) not in ADMIN_IDS:
        return jsonify({"error": "unauthorized"}), 403

    data = request.get_json()
    required = ["alert_type", "center_lat", "center_lon",
                "radius_m", "message", "url", "severity"]
    if not all(k in data for k in required):
        return jsonify({"error": "missing fields"}), 400

    # Save alert in DB
    alert_id = alerts_col.insert_one({
        "alert_type": data["alert_type"],
        "center": [float(data["center_lon"]), float(data["center_lat"])],
        "radius_m": int(data["radius_m"]),
        "message": data["message"],
        "url": data["url"],
        "severity": data["severity"],
        "ts": time.time(),
        "recipients": [],         # will fill soon
        "acknowledged": []        # user_ids who tapped â€œIâ€™m safeâ€
    }).inserted_id

    # Dispatch in background so HTTP call returns fast
    Thread(target=dispatch_alert_to_users,
           args=(str(alert_id),)).start()

    return jsonify({"alert_id": str(alert_id)}), 200


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TELEGRAM HANDLERS REGISTRATION â”€â”€â”€â”€â”€â”€â”€

# Register ConversationHandler FIRST for proper flow
conv = ConversationHandler(
    entry_points=[CommandHandler("report_hazard", report_hazard)],
    states={
        ASK_DESCRIPTION: [MessageHandler(Filters.text & ~Filters.command, get_description)],
        ASK_LOCATION:    [MessageHandler(Filters.location & ~Filters.update.edited_message, get_hazard_location)],
        ASK_DETAIL:      [MessageHandler(Filters.text & ~Filters.command, get_detail)],
        ASK_DANGER:      [CallbackQueryHandler(danger_response)],
        ASK_PHOTO: [
            MessageHandler(Filters.photo, get_photo),
            CommandHandler("skip", skip_photo)
        ],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
)
dispatcher.add_handler(conv)
info_handler = ConversationHandler(
    entry_points=[CommandHandler("info", info_start)],
    states={ASK_INFO: [MessageHandler(Filters.text & ~Filters.command, info_answer)]},
    fallbacks=[CommandHandler("cancel", info_cancel)],
)
dispatcher.add_handler(info_handler)
# <--- CONVERSATION HANDLER ADDED FIRST

# Then register other specific handlers
dispatcher.add_handler(CommandHandler("start", start))
dispatcher.add_handler(CommandHandler("help", help_cmd))
dispatcher.add_handler(CommandHandler("Emergency_alerts", alerts))
dispatcher.add_handler(CommandHandler("set_location", set_location))
# This general location handler should be AFTER the ConversationHandler
dispatcher.add_handler(MessageHandler(Filters.location & ~Filters.update.edited_message, handle_location))
dispatcher.add_handler(CommandHandler("my_reports", my_reports))

dispatcher.add_handler(
    CallbackQueryHandler(view_report_callback, pattern=r'^view_report_')
)



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WEBHOOK & FLASK RUN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Function to set up webhook and run Flask app
@app.route("/webhook", methods=["POST"])
def webhook():
    if request.method == "POST":
        update = Update.de_json(request.get_json(force=True), bot)
        logger.info(f"Received webhook update: {update.update_id}")
        dispatcher.process_update(update)
        return "OK", 200
    return "Method Not Allowed", 405 # For GET requests to webhook URL

@app.route("/")
def index():
    return "IndySafetyAssistBot running!", 200 # Explicitly return 200

# â”€â”€â”€â”€â”€â”€â”€â”€â”€ RUN FLASK & NGROK â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This part goes at the very end of your Colab cell
def run_flask_app():
    logger.info("Starting Flask app...")
    app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False)

# Start Flask in a separate thread
flask_thread = Thread(target=run_flask_app)
flask_thread.daemon = True # Allows thread to exit when main program exits
flask_thread.start()
app.run(port=8443)
# Keep the main thread alive for the dispatcher
# (or consider using app.run_polling() if you only use long-polling and not webhooks)
# For webhooks, the dispatcher doesn't need to be explicitly started in a loop if Flask handles webhook updates
# The dispatcher processes updates that Flask passes to it via the webhook route.

"""# Create the Bot Server

# Set Webhook
"""

import requests

# Replace with your ngrok HTTPS URL
url = "https://c3a0-34-74-152-79.ngrok-free.app/webhook"
token = "7418699247:AAF2eI8vUwDKcU9iXVl8rajdiRt7bjoEMsI"
requests.get(f"https://api.telegram.org/bot{token}/setWebhook?url={url}")

"""# Start the Flask App to Receive Webhooks

# Report hazard
"""